\chapter{Introduction to Fuzzing}
\subsection{Background}
For the purpose of introducing this topic, fuzzing is a software testing approach where a system is sent high volumes of test cases that are generated at random by another program. Input cases are generated as random bytes and submitted to the target program where they are processed and monitored for output. While the simplicity of fuzz testing is trivial, it quickly proved to be effective at finding faults and incorrect states inside a program. Therefore, fuzz testing which originated in 1988 continues to be in use today.
\\
\\
Early fuzz testing wasn't without its drawbacks. Most notably, the use of highly structured data creates a gatekeeper effect where many test inputs become invalid. This led to the development of mutation based fuzzing. Some input data is modified to create a different test set. This is where \texttt{afl} comes in. As a modern fuzzer, \texttt{afl} uses mutated inputs to develop test cases that improve the coverage of traditional fuzzer's. 
\\

The software is typically comprised of three components. 
\begin{itemize}
\item \textbf{Generator} - Creates test inputs that are fed to a delivery mechanism. Generators may use heuristics, templates, grammars, or data blocks to build inputs. 

\item \textbf{Delivery Mechanism} - Takes input from the generator and feeds it to the targeted binary. Examples of delivery mechanisms include network transmissions, files, and API parameters.

\item \textbf{Monitoring System} - Observes the binary as it processes the input cases and detects when illegal states or faults occur. Monitoring Systems can vary in their complexity. Early implementations where much like a black box. Only the output was observed. More modern fuzzers like \texttt{afl} monitor the internal states of the system under test.
\end{itemize}


\subsection {What it solves}

\begin{enumerate}

\item {Portability}

Manual tests are often specific to the software under testing and cannot be replicated to different programs. Testing with \texttt{afl} can be applied to any c or c++ program. 

\item {Human testing}

Best practices for software testing typically involve a separation between developer and tester. However, the test engineer often needs some knowledge of the underlying system. This increases the cost of the development, both in time and financial resources. In addition to cost, humans are typically prone to positive case testing. Where most testing is derived by the intended use cases. Little testing may be applied to bad actor scenarios. The randomness of testing applied by \texttt{afl} ensures a broad range of testing scenarios. 

\item{Automation}

Easy automation with little configuration adds the ability to send a high volumes of test inputs to identify illegal states and faults. Mutating inputs ensure the infection and propagation required for complete code coverage. This satisfies the RIPR model. 

\item {Binary Only}

\texttt{afl} has a binary-only mode which runs test cases on a compiled program. This allows test cases when source code is not available. 

\end{enumerate}


