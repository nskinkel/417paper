\chapter{Introduction to Fuzzing}

In 1988 Professor Barton Miller and his associates at the University of Wisconsin began the development of a project called "fuzzer" \cite{mil-fuzz}. A software testing approach involving a target binary that is sent random input from a foreign program.
 Input cases are generated as random bytes and submitted to the target binary where it is processed and monitored for output. While the simplicity of fuzz testing is trivial, it quickly proved to be effective at finding faults and incorrect states inside a program. 
However, while useful, early development of fuzzers faced two problems. The determination of internal states and the inefficiencies of random data.

\subsection{Problem 1 : Internal States}
Limitations to fuzz testing were originally it's greatest strength. Traditional fuzzing enabled software testers to perform input cases on binary executables. 
However, this led to a black box testing model where only the output was known.  In other words, it was difficult to know the internal states if no fault was received. It was also difficult to determine
if a binary reached a true fault. Denial's of service or authentication errors may have presented themselves as faults, but were really a protection mechanism.

\subsection{Problem 2 :  Inefficiencies}
Early fuzzer's operated purely random inputs against highly structured data. This created a gatekeeper effect where many test cases were invalid and rendered the fuzzer inefficient. 
For example, a HTTP protocol GET request  must start with "GET / HTTP/1.0 \textbackslash n\textbackslash n" and this will only occur 1 in $256^{16}$ times \cite{mil-fuzz}. 
\\\\
Much of the input in early fuzzer implementations failed to reach blocks of code with any degree of significance due to lack of knowledge and randomness of test cases. In fact, the fuzzer had no way of really knowing if a block of code was even executed
unless there was an output. This carries a level of uncertainty to the depth and level of code coverage.  Another issue was the delivery of structured data. Assuming input could be modified
dynamically to match constraints, how would the fuzzer know how to deserialize and present it to the system under test at runtime? Fuzzing frameworks needed some method to convert binary to structured data. 